<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20160207181637.1"><vh>Startup</vh>
<v t="ekr.20160207181648.1"><vh>@settings</vh>
<v t="ekr.20180706073424.1"><vh>@bool run-pyflakes-on-write = False</vh></v>
<v t="ekr.20160207182535.1"><vh>@bool preload-find-pattern = False</vh></v>
</v>
<v t="ekr.20210805061637.1"><vh>buttons</vh>
<v t="ekr.20210804020706.1"><vh>@button coverage</vh></v>
<v t="ekr.20210804060105.1"><vh>@button unitttest</vh></v>
<v t="ekr.20210807133351.1"><vh>@button unitttest1</vh></v>
<v t="ekr.20210804021331.1"><vh>@button msf</vh></v>
</v>
</v>
<v t="ekr.20210810052527.1"><vh>Notes</vh>
<v t="ekr.20210810052454.1"><vh>No longer used</vh>
<v t="ekr.20210810052805.1"><vh> Unused python 2 visitors</vh>
<v t="ekr.20160318141204.65"><vh>f.Exec</vh></v>
<v t="ekr.20160318141204.41"><vh>f.Index</vh></v>
<v t="ekr.20160318141204.74"><vh>f.Print</vh></v>
<v t="ekr.20160318141204.46"><vh>f.Repr</vh></v>
<v t="ekr.20160318141204.80"><vh>f.TryExcept</vh></v>
<v t="ekr.20160318141204.81"><vh>f.TryFinally</vh></v>
</v>
<v t="ekr.20210809094659.1"><vh>launch_msf.py</vh></v>
<v t="ekr.20160318141204.5"><vh>merge_types</vh></v>
<v t="ekr.20210804153200.1"><vh>script convert-at-test (no longer necessary)</vh></v>
<v t="ekr.20160207051429.1"><vh>test_merge_types</vh></v>
</v>
<v t="ekr.20210805053830.1"><vh>Notes for #18: full coverage</vh>
<v t="ekr.20210806162349.1"><vh>--- changed &amp; new AstFormatter visitors</vh>
<v t="ekr.20160318141204.91"><vh>arg_formatter.Constants &amp; Name</vh></v>
<v t="ekr.20160318141204.59"><vh>f.AnnAssign &amp; Assign</vh></v>
<v t="ekr.20160318141204.31"><vh>f.arguments</vh></v>
<v t="ekr.20160318141204.35"><vh>f.Call &amp; f.keyword</vh>
<v t="ekr.20160318141204.36"><vh>f.keyword</vh></v>
</v>
<v t="ekr.20160318141204.20"><vh>f.ClassDef</vh></v>
<v t="ekr.20210804214511.1"><vh>f.Constant</vh></v>
<v t="ekr.20160318141204.75"><vh>f.Raise</vh></v>
<v t="ekr.20160318141204.18"><vh>f.visit</vh></v>
<v t="ekr.20160318141204.83"><vh>f.With</vh></v>
<v t="ekr.20160318141204.84"><vh>f.Yield</vh></v>
<v t="ekr.20160318141204.85"><vh>f.YieldFrom</vh></v>
</v>
<v t="ekr.20210807151105.1"><vh>--- changed StubFormatter visitors</vh>
<v t="ekr.20160318141204.168"><vh>sf.Return</vh></v>
<v t="ekr.20160318141204.167"><vh>sf.UnaryOp</vh></v>
</v>
<v t="ekr.20210807213637.1"><vh>--- changed StubTraverser methods</vh>
<v t="ekr.20160318141204.191"><vh>st.format_return_expressions</vh></v>
</v>
</v>
</v>
<v t="ekr.20210810115607.1"><vh>Files</vh>
<v t="ekr.20160128225533.1"><vh>@clean .gitignore</vh></v>
<v t="ekr.20160128102557.1"><vh>@clean example.cfg</vh></v>
<v t="ekr.20160126153220.1"><vh>@clean make_stub_files.cfg</vh></v>
<v t="ekr.20160330201030.1"><vh>@clean PKG-INFO.TXT</vh></v>
<v t="ekr.20160211110739.1"><vh>@clean README.md</vh>
<v t="ekr.20160211110807.1"><vh>Overview</vh></v>
<v t="ekr.20160211113019.1"><vh>Quick start</vh></v>
<v t="ekr.20160211110810.1"><vh>Command-line arguments</vh></v>
<v t="ekr.20160211110810.2"><vh>The configuration file</vh>
<v t="ekr.20160211111807.1"><vh>Patterns</vh></v>
<v t="ekr.20160211111823.1"><vh>[Global]</vh></v>
<v t="ekr.20160211111839.1"><vh>[Def Name Patterns]</vh></v>
<v t="ekr.20160211111901.1"><vh>[General Patterns]</vh></v>
</v>
<v t="ekr.20160211110810.3"><vh>Why this script is important</vh></v>
<v t="ekr.20160211110811.1"><vh>Summary</vh></v>
<v t="ekr.20210810053434.1"><vh>Release notes</vh></v>
</v>
<v t="ekr.20160207101607.1"><vh>@clean theory.md</vh></v>
<v t="ekr.20210809124558.1"><vh>@clean make_stub_files.pyi</vh>
<v t="ekr.20210809124613.1"><vh>Declarations</vh></v>
<v t="ekr.20210809124613.2"><vh>dump</vh></v>
<v t="ekr.20210809124613.3"><vh>dump_dict</vh></v>
<v t="ekr.20210809124613.4"><vh>dump_list</vh></v>
<v t="ekr.20210809124613.5"><vh>finalize</vh></v>
<v t="ekr.20210809124613.6"><vh>is_known_type</vh></v>
<v t="ekr.20210809124613.7"><vh>main</vh></v>
<v t="ekr.20210809124613.8"><vh>reduce_types</vh></v>
<v t="ekr.20210809124613.9"><vh>truncate</vh></v>
<v t="ekr.20210809124613.10"><vh>class AstFormatter</vh>
<v t="ekr.20210809124613.11"><vh>AstFormatter.format</vh></v>
<v t="ekr.20210809124613.12"><vh>AstFormatter.visit</vh></v>
<v t="ekr.20210809124613.13"><vh>AstFormatter.do_ClassDef</vh></v>
<v t="ekr.20210809124613.14"><vh>AstFormatter.do_FunctionDef</vh></v>
<v t="ekr.20210809124613.15"><vh>AstFormatter.do_Interactive</vh></v>
<v t="ekr.20210809124613.16"><vh>AstFormatter.do_Module</vh></v>
<v t="ekr.20210809124613.17"><vh>AstFormatter.do_Lambda</vh></v>
<v t="ekr.20210809124613.18"><vh>AstFormatter.do_Expr</vh></v>
<v t="ekr.20210809124613.19"><vh>AstFormatter.do_Expression</vh></v>
<v t="ekr.20210809124613.20"><vh>AstFormatter.do_GeneratorExp</vh></v>
<v t="ekr.20210809124613.21"><vh>AstFormatter.do_AugLoad</vh></v>
<v t="ekr.20210809124613.22"><vh>AstFormatter.do_Del</vh></v>
<v t="ekr.20210809124613.23"><vh>AstFormatter.do_Load</vh></v>
<v t="ekr.20210809124613.24"><vh>AstFormatter.do_Param</vh></v>
<v t="ekr.20210809124613.25"><vh>AstFormatter.do_Store</vh></v>
<v t="ekr.20210809124613.26"><vh>AstFormatter.do_arguments</vh></v>
<v t="ekr.20210809124613.27"><vh>AstFormatter.do_arg</vh></v>
<v t="ekr.20210809124613.28"><vh>AstFormatter.do_Attribute</vh></v>
<v t="ekr.20210809124613.29"><vh>AstFormatter.do_Bytes</vh></v>
<v t="ekr.20210809124613.30"><vh>AstFormatter.do_Call</vh></v>
<v t="ekr.20210809124613.31"><vh>AstFormatter.do_keyword</vh></v>
<v t="ekr.20210809124613.32"><vh>AstFormatter.do_Constant</vh></v>
<v t="ekr.20210809124613.33"><vh>AstFormatter.do_comprehension</vh></v>
<v t="ekr.20210809124613.34"><vh>AstFormatter.do_Dict</vh></v>
<v t="ekr.20210809124613.35"><vh>AstFormatter.do_Ellipsis</vh></v>
<v t="ekr.20210809124613.36"><vh>AstFormatter.do_ExtSlice</vh></v>
<v t="ekr.20210809124613.37"><vh>AstFormatter.do_FormattedValue</vh></v>
<v t="ekr.20210809124613.38"><vh>AstFormatter.do_JoinedStr</vh></v>
<v t="ekr.20210809124613.39"><vh>AstFormatter.do_List</vh></v>
<v t="ekr.20210809124613.40"><vh>AstFormatter.do_ListComp</vh></v>
<v t="ekr.20210809124613.41"><vh>AstFormatter.do_Name</vh></v>
<v t="ekr.20210809124613.42"><vh>AstFormatter.do_NameConstant</vh></v>
<v t="ekr.20210809124613.43"><vh>AstFormatter.do_Num</vh></v>
<v t="ekr.20210809124613.44"><vh>AstFormatter.do_Slice</vh></v>
<v t="ekr.20210809124613.45"><vh>AstFormatter.do_Str</vh></v>
<v t="ekr.20210809124613.46"><vh>AstFormatter.do_Subscript</vh></v>
<v t="ekr.20210809124613.47"><vh>AstFormatter.do_Tuple</vh></v>
<v t="ekr.20210809124613.48"><vh>AstFormatter.do_BinOp</vh></v>
<v t="ekr.20210809124613.49"><vh>AstFormatter.do_BoolOp</vh></v>
<v t="ekr.20210809124613.50"><vh>AstFormatter.do_Compare</vh></v>
<v t="ekr.20210809124613.51"><vh>AstFormatter.do_UnaryOp</vh></v>
<v t="ekr.20210809124613.52"><vh>AstFormatter.do_IfExp</vh></v>
<v t="ekr.20210809124613.53"><vh>AstFormatter.do_Assert</vh></v>
<v t="ekr.20210809124613.54"><vh>AstFormatter.do_AnnAssign</vh></v>
<v t="ekr.20210809124613.55"><vh>AstFormatter.do_Assign</vh></v>
<v t="ekr.20210809124613.56"><vh>AstFormatter.do_AugAssign</vh></v>
<v t="ekr.20210809124613.57"><vh>AstFormatter.do_Break</vh></v>
<v t="ekr.20210809124613.58"><vh>AstFormatter.do_Continue</vh></v>
<v t="ekr.20210809124613.59"><vh>AstFormatter.do_Delete</vh></v>
<v t="ekr.20210809124613.60"><vh>AstFormatter.do_ExceptHandler</vh></v>
<v t="ekr.20210809124613.61"><vh>AstFormatter.do_For</vh></v>
<v t="ekr.20210809124613.62"><vh>AstFormatter.do_Global</vh></v>
<v t="ekr.20210809124613.63"><vh>AstFormatter.do_If</vh></v>
<v t="ekr.20210809124613.64"><vh>AstFormatter.do_Import</vh></v>
<v t="ekr.20210809124613.65"><vh>AstFormatter.get_import_names</vh></v>
<v t="ekr.20210809124613.66"><vh>AstFormatter.do_ImportFrom</vh></v>
<v t="ekr.20210809124613.67"><vh>AstFormatter.do_Nonlocal</vh></v>
<v t="ekr.20210809124613.68"><vh>AstFormatter.do_Pass</vh></v>
<v t="ekr.20210809124613.69"><vh>AstFormatter.do_Raise</vh></v>
<v t="ekr.20210809124613.70"><vh>AstFormatter.do_Return</vh></v>
<v t="ekr.20210809124613.71"><vh>AstFormatter.do_Starred</vh></v>
<v t="ekr.20210809124613.72"><vh>AstFormatter.do_Try</vh></v>
<v t="ekr.20210809124613.73"><vh>AstFormatter.do_While</vh></v>
<v t="ekr.20210809124613.74"><vh>AstFormatter.do_With</vh></v>
<v t="ekr.20210809124613.75"><vh>AstFormatter.do_Yield</vh></v>
<v t="ekr.20210809124613.76"><vh>AstFormatter.do_YieldFrom</vh></v>
<v t="ekr.20210809124613.77"><vh>AstFormatter.kind</vh></v>
<v t="ekr.20210809124613.78"><vh>AstFormatter.indent</vh></v>
<v t="ekr.20210809124613.79"><vh>AstFormatter.op_name</vh></v>
</v>
<v t="ekr.20210809124613.80"><vh>class AstArgFormatter(AstFormatter)</vh>
<v t="ekr.20210809124613.81"><vh>AstArgFormatter(AstFormatter).do_Constant</vh></v>
<v t="ekr.20210809124613.82"><vh>AstArgFormatter(AstFormatter).do_BoolOp</vh></v>
<v t="ekr.20210809124613.83"><vh>AstArgFormatter(AstFormatter).do_Bytes</vh></v>
<v t="ekr.20210809124613.84"><vh>AstArgFormatter(AstFormatter).do_Name</vh></v>
<v t="ekr.20210809124613.85"><vh>AstArgFormatter(AstFormatter).do_Num</vh></v>
<v t="ekr.20210809124613.86"><vh>AstArgFormatter(AstFormatter).do_Str</vh></v>
</v>
<v t="ekr.20210809124613.87"><vh>class Controller</vh>
<v t="ekr.20210809124613.88"><vh>Controller.__init__</vh></v>
<v t="ekr.20210809124613.89"><vh>Controller.make_stub_file</vh></v>
<v t="ekr.20210809124613.90"><vh>Controller.scan_command_line</vh></v>
<v t="ekr.20210809124613.91"><vh>Controller.scan_options</vh></v>
<v t="ekr.20210809124613.92"><vh>Controller.make_op_name_dict</vh></v>
<v t="ekr.20210809124613.93"><vh>Controller.create_parser</vh></v>
<v t="ekr.20210809124613.94"><vh>Controller.find_pattern_ops</vh></v>
<v t="ekr.20210809124613.95"><vh>Controller.get_config_string</vh></v>
<v t="ekr.20210809124613.96"><vh>Controller.init_parser</vh></v>
<v t="ekr.20210809124613.97"><vh>Controller.is_section_name</vh></v>
<v t="ekr.20210809124613.98"><vh>Controller.make_patterns_dict</vh></v>
<v t="ekr.20210809124613.99"><vh>Controller.scan_patterns</vh></v>
</v>
<v t="ekr.20210809124613.100"><vh>class LeoGlobals</vh>
<v t="ekr.20210809124613.101"><vh>LeoGlobals._callerName</vh></v>
<v t="ekr.20210809124613.102"><vh>LeoGlobals.caller</vh></v>
<v t="ekr.20210809124613.103"><vh>LeoGlobals.callers</vh></v>
<v t="ekr.20210809124613.104"><vh>LeoGlobals.cls</vh></v>
<v t="ekr.20210809124613.105"><vh>LeoGlobals.objToString</vh></v>
<v t="ekr.20210809124613.106"><vh>LeoGlobals.dictToString</vh></v>
<v t="ekr.20210809124613.107"><vh>LeoGlobals.listToString</vh></v>
<v t="ekr.20210809124613.108"><vh>LeoGlobals.tupleToString</vh></v>
<v t="ekr.20210809124613.109"><vh>LeoGlobals.pdb</vh></v>
<v t="ekr.20210809124613.110"><vh>LeoGlobals.printObj</vh></v>
<v t="ekr.20210809124613.111"><vh>LeoGlobals.shortFileName</vh></v>
<v t="ekr.20210809124613.112"><vh>LeoGlobals.splitLines</vh></v>
<v t="ekr.20210809124613.113"><vh>LeoGlobals.trace</vh></v>
</v>
<v t="ekr.20210809124613.114"><vh>class Pattern</vh>
<v t="ekr.20210809124613.115"><vh>Pattern.__init__</vh></v>
<v t="ekr.20210809124613.116"><vh>Pattern.__eq__</vh></v>
<v t="ekr.20210809124613.117"><vh>Pattern.__ne__</vh></v>
<v t="ekr.20210809124613.118"><vh>Pattern.__hash__</vh></v>
<v t="ekr.20210809124613.119"><vh>Pattern.__repr__</vh></v>
<v t="ekr.20210809124613.120"><vh>Pattern.is_balanced</vh></v>
<v t="ekr.20210809124613.121"><vh>Pattern.is_regex</vh></v>
<v t="ekr.20210809124613.122"><vh>Pattern.all_matches</vh></v>
<v t="ekr.20210809124613.123"><vh>Pattern.full_balanced_match</vh></v>
<v t="ekr.20210809124613.124"><vh>Pattern.match_balanced</vh></v>
<v t="ekr.20210809124613.125"><vh>Pattern.match</vh></v>
<v t="ekr.20210809124613.126"><vh>Pattern.match_entire_string</vh></v>
<v t="ekr.20210809124613.127"><vh>Pattern.replace</vh></v>
<v t="ekr.20210809124613.128"><vh>Pattern.replace_balanced</vh></v>
<v t="ekr.20210809124613.129"><vh>Pattern.replace_regex</vh></v>
</v>
<v t="ekr.20210809124613.130"><vh>class ReduceTypes</vh>
<v t="ekr.20210809124613.131"><vh>ReduceTypes.__init__</vh></v>
<v t="ekr.20210809124613.132"><vh>ReduceTypes.is_known_type</vh></v>
<v t="ekr.20210809124613.133"><vh>ReduceTypes.reduce_collection</vh></v>
<v t="ekr.20210809124613.134"><vh>ReduceTypes.reduce_numbers</vh></v>
<v t="ekr.20210809124613.135"><vh>ReduceTypes.reduce_types</vh></v>
<v t="ekr.20210809124613.136"><vh>ReduceTypes.reduce_unknowns</vh></v>
<v t="ekr.20210809124613.137"><vh>ReduceTypes.show</vh></v>
<v t="ekr.20210809124613.138"><vh>ReduceTypes.split_types</vh></v>
</v>
<v t="ekr.20210809124613.139"><vh>class Stub</vh>
<v t="ekr.20210809124613.140"><vh>Stub.__init__</vh></v>
<v t="ekr.20210809124613.141"><vh>Stub.__eq__</vh></v>
<v t="ekr.20210809124613.142"><vh>Stub.__ne__</vh></v>
<v t="ekr.20210809124613.143"><vh>Stub.__hash__</vh></v>
<v t="ekr.20210809124613.144"><vh>Stub.__repr__</vh></v>
<v t="ekr.20210809124613.145"><vh>Stub.level</vh></v>
<v t="ekr.20210809124613.146"><vh>Stub.parents</vh></v>
</v>
<v t="ekr.20210809124613.147"><vh>class StubFormatter(AstFormatter)</vh>
<v t="ekr.20210809124613.148"><vh>StubFormatter(AstFormatter).__init__</vh></v>
<v t="ekr.20210809124613.149"><vh>StubFormatter(AstFormatter).match_all</vh></v>
<v t="ekr.20210809124613.150"><vh>StubFormatter(AstFormatter).trace_visitor</vh></v>
<v t="ekr.20210809124613.151"><vh>StubFormatter(AstFormatter).do_Attribute</vh></v>
<v t="ekr.20210809124613.152"><vh>StubFormatter(AstFormatter).do_Constant</vh></v>
<v t="ekr.20210809124613.153"><vh>StubFormatter(AstFormatter).do_Bytes</vh></v>
<v t="ekr.20210809124613.154"><vh>StubFormatter(AstFormatter).do_Num</vh></v>
<v t="ekr.20210809124613.155"><vh>StubFormatter(AstFormatter).do_Str</vh></v>
<v t="ekr.20210809124613.156"><vh>StubFormatter(AstFormatter).do_Dict</vh></v>
<v t="ekr.20210809124613.157"><vh>StubFormatter(AstFormatter).do_List</vh></v>
<v t="ekr.20210809124613.158"><vh>StubFormatter(AstFormatter).do_Name</vh></v>
<v t="ekr.20210809124613.159"><vh>StubFormatter(AstFormatter).do_Tuple</vh></v>
<v t="ekr.20210809124613.160"><vh>StubFormatter(AstFormatter).do_BinOp</vh></v>
<v t="ekr.20210809124613.161"><vh>StubFormatter(AstFormatter).do_BoolOp</vh></v>
<v t="ekr.20210809124613.162"><vh>StubFormatter(AstFormatter).do_Compare</vh></v>
<v t="ekr.20210809124613.163"><vh>StubFormatter(AstFormatter).do_IfExp</vh></v>
<v t="ekr.20210809124613.164"><vh>StubFormatter(AstFormatter).do_Subscript</vh></v>
<v t="ekr.20210809124613.165"><vh>StubFormatter(AstFormatter).do_UnaryOp</vh></v>
<v t="ekr.20210809124613.166"><vh>StubFormatter(AstFormatter).do_Call</vh></v>
<v t="ekr.20210809124613.167"><vh>StubFormatter(AstFormatter).do_Return</vh></v>
</v>
<v t="ekr.20210809124613.168"><vh>class StubTraverser(ast.NodeVisitor)</vh>
<v t="ekr.20210809124613.169"><vh>StubTraverser(ast.NodeVisitor).__init__</vh></v>
<v t="ekr.20210809124613.170"><vh>StubTraverser(ast.NodeVisitor).add_stub</vh></v>
<v t="ekr.20210809124613.171"><vh>StubTraverser(ast.NodeVisitor).indent</vh></v>
<v t="ekr.20210809124613.172"><vh>StubTraverser(ast.NodeVisitor).out</vh></v>
<v t="ekr.20210809124613.173"><vh>StubTraverser(ast.NodeVisitor).run</vh></v>
<v t="ekr.20210809124613.174"><vh>StubTraverser(ast.NodeVisitor).output_stubs</vh></v>
<v t="ekr.20210809124613.175"><vh>StubTraverser(ast.NodeVisitor).output_time_stamp</vh></v>
<v t="ekr.20210809124613.176"><vh>StubTraverser(ast.NodeVisitor).update</vh></v>
<v t="ekr.20210809124613.177"><vh>StubTraverser(ast.NodeVisitor).get_stub_file</vh></v>
<v t="ekr.20210809124613.178"><vh>StubTraverser(ast.NodeVisitor).parse_stub_file</vh></v>
<v t="ekr.20210809124613.179"><vh>StubTraverser(ast.NodeVisitor).merge_stubs</vh></v>
<v t="ekr.20210809124613.180"><vh>StubTraverser(ast.NodeVisitor).check_delete</vh></v>
<v t="ekr.20210809124613.181"><vh>StubTraverser(ast.NodeVisitor).flatten_stubs</vh></v>
<v t="ekr.20210809124613.182"><vh>StubTraverser(ast.NodeVisitor).flatten_stubs_helper</vh></v>
<v t="ekr.20210809124613.183"><vh>StubTraverser(ast.NodeVisitor).find_parent_stub</vh></v>
<v t="ekr.20210809124613.184"><vh>StubTraverser(ast.NodeVisitor).find_stub</vh></v>
<v t="ekr.20210809124613.185"><vh>StubTraverser(ast.NodeVisitor).sort_stubs_by_hierarchy</vh></v>
<v t="ekr.20210809124613.186"><vh>StubTraverser(ast.NodeVisitor).trace_stubs</vh></v>
<v t="ekr.20210809124613.187"><vh>StubTraverser(ast.NodeVisitor).visit_ClassDef</vh></v>
<v t="ekr.20210809124613.188"><vh>StubTraverser(ast.NodeVisitor).visit_FunctionDef</vh></v>
<v t="ekr.20210809124613.189"><vh>StubTraverser(ast.NodeVisitor).format_arguments</vh></v>
<v t="ekr.20210809124613.190"><vh>StubTraverser(ast.NodeVisitor).munge_arg</vh></v>
<v t="ekr.20210809124613.191"><vh>StubTraverser(ast.NodeVisitor).format_returns</vh></v>
<v t="ekr.20210809124613.192"><vh>StubTraverser(ast.NodeVisitor).format_return_expressions</vh></v>
<v t="ekr.20210809124613.193"><vh>StubTraverser(ast.NodeVisitor).get_def_name</vh></v>
<v t="ekr.20210809124613.194"><vh>StubTraverser(ast.NodeVisitor).remove_recursive_calls</vh></v>
<v t="ekr.20210809124613.195"><vh>StubTraverser(ast.NodeVisitor).visit_Return</vh></v>
</v>
<v t="ekr.20210809124613.196"><vh>class TestMakeStubFiles(unittest.TestCase)</vh>
<v t="ekr.20210809124613.197"><vh>TestMakeStubFiles(unittest.TestCase).test_rt_is_known_type</vh></v>
<v t="ekr.20210809124613.198"><vh>TestMakeStubFiles(unittest.TestCase).test_rt_reduce_numbers</vh></v>
<v t="ekr.20210809124613.199"><vh>TestMakeStubFiles(unittest.TestCase).test_rt_reduce_types</vh></v>
<v t="ekr.20210809124613.200"><vh>TestMakeStubFiles(unittest.TestCase).test_rt_split_types</vh></v>
<v t="ekr.20210809124613.201"><vh>TestMakeStubFiles(unittest.TestCase).test_st_find</vh></v>
<v t="ekr.20210809124613.202"><vh>TestMakeStubFiles(unittest.TestCase).test_st_flatten_stubs</vh></v>
<v t="ekr.20210809124613.203"><vh>TestMakeStubFiles(unittest.TestCase).test_st_merge_stubs</vh></v>
<v t="ekr.20210809124613.204"><vh>TestMakeStubFiles(unittest.TestCase).test_st_format_returns</vh></v>
<v t="ekr.20210809124613.205"><vh>TestMakeStubFiles(unittest.TestCase).test_bug2_empty</vh></v>
<v t="ekr.20210809124613.206"><vh>TestMakeStubFiles(unittest.TestCase).test_bug2_non_empty</vh></v>
<v t="ekr.20210809124613.207"><vh>TestMakeStubFiles(unittest.TestCase).test_bug3</vh></v>
<v t="ekr.20210809124613.208"><vh>TestMakeStubFiles(unittest.TestCase).test_finalize</vh></v>
<v t="ekr.20210809124613.209"><vh>TestMakeStubFiles(unittest.TestCase).test_is_known_type</vh></v>
<v t="ekr.20210809124613.210"><vh>TestMakeStubFiles(unittest.TestCase).test_truncate</vh></v>
<v t="ekr.20210809124613.211"><vh>TestMakeStubFiles(unittest.TestCase).test_ast_arg_formatter_class</vh></v>
<v t="ekr.20210809124613.212"><vh>TestMakeStubFiles(unittest.TestCase).test_ast_formatter_class</vh></v>
<v t="ekr.20210809124613.213"><vh>TestMakeStubFiles(unittest.TestCase).test_ast_formatter_class_on_file</vh></v>
<v t="ekr.20210809124613.214"><vh>TestMakeStubFiles(unittest.TestCase).test_controller_class</vh></v>
<v t="ekr.20210809124613.215"><vh>TestMakeStubFiles(unittest.TestCase).test_file_msb</vh></v>
<v t="ekr.20210809124613.216"><vh>TestMakeStubFiles(unittest.TestCase).test_pattern_class</vh></v>
<v t="ekr.20210809124613.217"><vh>TestMakeStubFiles(unittest.TestCase).test_stub_class</vh></v>
<v t="ekr.20210809124613.218"><vh>TestMakeStubFiles(unittest.TestCase).test_stub_formatter_class</vh></v>
<v t="ekr.20210809124613.219"><vh>TestMakeStubFiles(unittest.TestCase).test_stub_traverser_class</vh></v>
</v>
</v>
<v t="ekr.20210810102041.1"><vh>@file scripts/wax_off.py</vh></v>
<v t="ekr.20160318141204.1"><vh>@file make_stub_files.py</vh></v>
</v>
<v t="ekr.20210810053434.1"></v>
</vnodes>
<tnodes>
<t tx="ekr.20160126153220.1">@language config

# A configuration file to make stubs for make_stub_files.py itself.

[Global]

files: make_stub_files.py
    
output_directory: .
    
prefix_lines:
    from typing import Any, Dict, Optional, Sequence, Tuple, Union
        # At present, I don't understand how to tell mypy about ast.Node
        # import ast
        # Node = ast.Node
    Node = Any

[Def Name Patterns]

# The returns are inherent in the design of make_stub_files.py:
AstFormatter.do_*: str
StubFormatter.do_*: str
StubTraverser.do_*: str

# Test of regex pattern.
.*__hash__$: int

# Pattern.all_matches: Sequence
# Pattern.full_balanced_match: Optional[int]
# Pattern.match_balanced: int
# Pattern.match_entire_string: bool
# StandAloneMakeStubFile.scan_types: Dict[str, str]

# StubTraverser.format_returns: str
# StubTraverser.match_return_patterns: Tuple[bool,str]
# StubTraverser.match_return_pattern: Optional[str]
# StubTraverser.match_balanced: int

[General Patterns]

# Declarations of names...
NotImplemented: bool
a: str
aList: List[Any]
comments: str
controller: StandAloneMakeStubFile
find_s: str
fn: str
found: str
general_patterns: List[Pattern]
group: str
i1: int
i2: int
i: int
j1: int
j2: int
j: int
n1: int
n2: int
n: int
name: str
ndots: int
node: Node
parser: optparse.OptionParser
patterns: List
repl_s: str
s: str
s1: str
s2: str
# s[1-2]?$: str
strict: bool
trace: bool
# New known functions
endswith(*): bool 

# Known functions...
os.path.basename(*): str
os.sep.join(*): str
sep.join(*): str
self.__eq__(*): bool
self.__ne__(*): bool
self.__gt__(*): bool
self.__lt__(*): bool
all(*): bool
any(*): bool

int(*): int
hash(*): int
len(*): int
repr(*): str
sorted(*): str
str%(*): str
str.join(*): str
r[*]: str
# Put this in the code.
str[*]: str
###.*\.__name__$: str
###.*\.hash()$: int
</t>
<t tx="ekr.20160128102557.1"># An example configuration file for make_stub_files.py.
# By default, make_stub_files.py uses ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:
    
    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.
    
output_directory: ~/stubs
    
prefix_lines:
    # Lines to be inserted at the start of each stub file.

    from typing import TypeVar
    T = TypeVar('T', int, float, complex)
    
# Notes about patterns used below:
#
#  **Balanced patterns** contain either (*), [*], or {*}.
#  Unlike regular expressions, balanced patterns match only balanced brackets.
#
#  Both regex and balanced patterns may appear in each section.
#  However, balanced patterns will never match argument names.
#
#  Patterns are matched in the order they appear in each section,
#  but the .* pattern (if present) will match last, regardless of its
#  position in the section.
    
[Def Name Patterns]

# These regex patterns give the return types of functions or methods.
#
# Patterns for methods should match class_name.method_name.
#
# Patterns in this section *override* all other patterns,
# so you should use these patterns only if:
#
# - No other pattern properly handles the function or method, or
#
# - The pattern specifies functions that should all return the same value.
#   For example, all ast tree traversers should have the same signatures.
#
# It may be unwise to use .* in this section, but the choice is yours.

[Argument Patterns]

# The regex patterns in this section apply only when assigning types
# to *arguments* to functions or methods. Patterns match argument names.
# Typically, most patterns can be put [General Patterns] section instead.

[General Patterns]

# The patterns in this section may be either regex or balanced patterns.
# Patterns in this section are applied both to arguments and return expressions.
# These patterns are applied *once* to argument names and *repeatedly* to
# return types until no further matches can be made.

aList[1-3]?: Sequence
i: int
j: int
k: int
node: ast.Ast
s[1-3]?: str

[Return Patterns]

# The patterns in this section may be either regex or balanced patterns.
# Patterns in this section are applied only to return expressions.
# These patterns are applied *repeatedly* to return expressions
# until no further matches can be made.

# Balanced patterns...

repr(*): str
str.join(*): str
str.replace(*): str
str%(*): str
str%str: str

# Regex patterns...

.*__name__: str
</t>
<t tx="ekr.20160128225533.1">*.pyc
*.pyi
test/*.pyc
__pycache__/
.mypy_cache/
.cache/
.coverage
htmlcov/
*.egg-info/
dist/
</t>
<t tx="ekr.20160207051429.1">def test_merge_types(self):

    a, c, f, i, l, n = ('Any', 'complex', 'float', 'int', 'long', 'number')
    none = 'None'
    La, Lc = ['Any'], ['complex']
    Lac, Lai, Lan = ['Any', 'complex'], ['Any', 'int'], ['Any', 'None']
    Laci = ['Any', 'complex', 'int']
    Lnone = ['None']
    table = (
        (none, Lnone,   Lnone),
        (none, none,    Lnone),
        (a, none,       Lan),
        (a, a,          La),
        (La, a,         La),
        (Lac, a,        Lac),
        (Lac, i,        Laci),
        (Lac, Lai,      Laci),
    )
    for a1, a2, expected in table:
        got = merge_types(a1, a2)
        self.assertEqual(expected, got)
</t>
<t tx="ekr.20160207101607.1">@language rest
@wrap

This is the theory-of-operation document for the `make_stub_files` script. It is intentionally brief. Please [ask questions](#summary) if anything is unclear.

### Prerequisites

Maintainers should be familiar with the following:

- The [Python 3 ast class](https://docs.python.org/3/library/ast.html).
  You should know what a tree traversal is.
- [Pep 484](https://www.python.org/dev/peps/pep-0484/) and
  [Python's typing module](https://docs.python.org/3/library/typing.html).
  Having a clear **target language** greatly simplifies this project.
  
You don't need to know anything about type inference.

### High level description

This script is a modified code formatter. This script traverses the incoming ast tree *once* from the top down, generating results from the bottom up. There is only a *single* traversal, composed of four traversal classes. (See [below](#traversers) for details). This traversal produces a stub for every class and def line. To do this, it **replaces expressions with type hints**. In other words, the goal is to **reduce** expressions to **known types**, as defined by Pep 484.

The StubFormatter visitors do most of the work of type reduction. They delegate type reduction to the following helpers:

1. **`ReduceTypes.reduce_types(aList)`** reduces a *list* of 0 or more types to a *string* representing a type hint. It returns 'Any' for unknown types. At the top of the traversal, StubTraverser.do_FunctionDef also calls reduce_types (via helpers) on the list of all return expressions.

2. **`StubFormatter.match_all(node, s)`** applies all user-patterns to s and returns the result.

3. **`ReduceTypes.is_known_type(s)`** embodies the known types as defined in Pep 484 and the typing module.

In short, visitors are hardly more complex than the corresponding AstFormatter methods.

**Notes**:

- The `sf.do_Attribute` and `sf.do_Name` visitors look up names in `sf.names_dict`. This is much faster than matching patterns.

- `sf.match_all` is very fast because it only applies patterns that *could possibly* match at the node being visited. Those patterns are:

        self.patterns_dict.get(node.__class__.__name__, []) + self.regex_patterns
        
  That is, all regex patterns are applied "everywhere" in return expressions.

- The startup code create `names_dict`, `patterns_dict` and `regex_patterns` data structures. That's all you have to know about the startup code.

- The Pattern class handles almost all details of pattern matching. This shields the rest of the code from knowledge of patterns. In particular, `sf.match_all` knows nothing about patterns.

### Examples

A few examples may make this script's operation clearer. The --trace-matches and --trace-reduce switches turn on detailed traces that show exactly when and where reductions happen, and what the resulting type hints are. These traces are the truth.  Believe them, not words here.

Given the file truncate.py:

    def truncate(s, n):
        """Return s truncated to n characters."""
        return s if len(s) &lt;= n else s[:n-3] + '...'
        
The script produces this output with the --verbose option in effect:

    def truncate(s: str, n: int) -&gt; str: ...
        #   0: return s if len(s)&lt;=n else s[:n-3]+'...'
        #   0: return str
        
Here is the output with --trace-reduce --trace-matches in effect:

    make_stub_files.py -c make_stub_files.cfg truncate.py -v -o --trace-reduce --trace-matches
    
    callers                     pattern                types ==&gt; hint    
    =======                     =======         ========================
    reduce_types: do_BinOp                      [int, number] ==&gt; number
    match_all:    do_Subscript  str[*]: str      str[:number] ==&gt; str
    reduce_types: do_IfExp                               str] ==&gt; str

Finally, here is *part* of the result of tracing make_stub_files.py itself::

          context                   pattern                                                          types ==&gt; hint    
    =============================== ================ =========================================================================
    reduce_types: do_IfExp                                                    [bool, is_known_type(inner)] ==&gt; ? Any
    reduce_types: do_IfExp                                                    [bool, is_known_type(inner)] ==&gt; ? Any
    match_all:    do_Call           all(*): bool                  all(is_known_type(z.strip()) for z in... ==&gt; bool
    reduce_types: is_known_type                                                                [Any, bool] ==&gt; Union[Any, bool]
    match_all:    do_Call           sorted(*): str                                      sorted(Set[r1+r2]) ==&gt; str
    reduce_types: show                                  [show_helper(List[Any][:], known, str, str, bool)] ==&gt; ? Any
    match_all:    do_Subscript      r[*]: str                                                    r[number] ==&gt; str
    match_all:    do_Call           str.join(*): str                                         str.join(str) ==&gt; str
    reduce_types: reduce_types                       [show(str), show(str, known=bool), show_helper(Li...] ==&gt; ? Any
    reduce_types: do_BinOp                                                                   [int, number] ==&gt; number
    match_all:    do_Subscript      str[*]: str                                               str[:number] ==&gt; str
    reduce_types: do_IfExp                                                                           [str] ==&gt; str
    
    class AstFormatter
    
    reduce_types: do_BoolOp                                                              [val, val.strip()] ==&gt; ? Any
    reduce_types: do_BoolOp                                                                      [Any, str] ==&gt; Union[Any, str]
    reduce_types: visit                                                                               [str] ==&gt; str
    reduce_types: do_IfExp                                                                            [str] ==&gt; str
    match_all:    do_Call           repr(*): str                                               repr(Node.n) ==&gt; str
    reduce_types: get_import_names                                                                 [result] ==&gt; ? Any
    reduce_types: kind                                                            [Node.__class__.__name__] ==&gt; ? Any
    
This trace contains all essential data concerning pattern matching and type reduction.

Enable tracing in various visitors if you need more data.

&lt;a name="traversers"/&gt;
### Traversers

As stated above, this script traverses the parse tree *once*, using four different traversal classes. Each traverser produces the results needed at a particular point of the traversal. Imo, using separate traversal classes is good style, even though it would be straightforward to use a single class. Indeed, each class has a distinct purpose...

#### AstFormatter

This is the base formatter class. It defines the default formatting for each kind of node. More importantly, it emphasizes that subclasses must return strings, *never* lists. The `AstFormatter.visit` method checks that this is so. This assertion guarantees that subclasses must call `st.reduce_types` to convert a list of possible types into a single string representing their union.

#### StubTraverser

This class drives the traversal. It is a subclass of ast.NodeVisitor. No custom visit method is needed. Visitors are *not* formatters--they *use* formatters to produce stubs. This class overrides only the visitors for ClassDef, FunctionDef and Return ast nodes. The FunctionDef visitor invokes the StubFormatter class to format all the functions return statements. The FunctionDef visitor invokes the AstArgFormatter to format names in argument lists.

#### StubFormatter

This class formats return statements. The overridden visitors of this class replace constants and operators with their corresponding type hints. The do_BinOp method contains hard-coded patterns for creating type hints. More could be added. The script is truly simple because the visitor methods of this class are hardly more complex than the corresponding methods of the AstFormatter class.

### AstArgFormatter

This class works just like the StubFormatter class except that does *not* apply patterns to Name nodes. As the name implies, it is used to format arguments in function definitions. It could easily be merged into the StubFormatter class, but imo having a separate class is cleaner and even a bit safer.

### Unit testing

August, 2021: make_stub_files.py now contains traditional unit tests.  See the TestMakeStubFiles class.

Run these unit tests with:

    cd make_stub_files
    python -m unittest make_stub_files
    
Run coverage tests with:

    cd make_stub_files
    python -m pytest --cov-report html --cov-report term-missing --cov make_stub_files make_stub_files.py

&lt;a name="summary"/&gt;
### Summary

make_stub_files.py is a straightforward tree traversal. Or so it seems to me.
Please feel free to ask questions.

Edward K. Ream  
edreamleo@gmail.com</t>
<t tx="ekr.20160207181637.1"></t>
<t tx="ekr.20160207181648.1"></t>
<t tx="ekr.20160207182535.1"></t>
<t tx="ekr.20160211110739.1">@language rest
@wrap

This is the readme file for `make_stub_files.py (msf)`. This file explains what msf does and how it works.

Are you sure you want to use this program? For python 3 programs, including mypy annotations directly in your sources is a better alternative. Leo's new add-mypy-annotations command handles most of the tedious details of inserting annotations.

Also, several other tools create mypy stubs:

- [MonkeyType](https://monkeytype.readthedocs.io/en/latest/index.html) (Python 3),
- [PyAnnotate](https://github.com/dropbox/pyannotate),
- [stubgen](https://mypy.readthedocs.io/en/stable/stubgen.html).

After a brief overview, a step-by-step section will get you started. Full source code for make_stub_files.py is in its [github repository](https://github.com/edreamleo/make-stub-files). Everything is in the public domain.

@others</t>
<t tx="ekr.20160211110807.1">
### Overview

This script makes a stub (.pyi) file in the **output directory** for each **source file** listed on the command line (wildcard file names are supported). This script never creates directories automatically, nor does it overwrite stub files unless the --overwrite command-line option is in effect.

GvR says, "We actually do have a [stub generator](https://github.com/JukkaL/mypy/blob/master/mypy/stubgen.py) as part of mypy now (it has a few options) but yours has the advantage of providing a way to tune the generated signatures...This allows for a nice iterative way of developing stubs."

The script does no type inference. Instead, the user supplies **patterns** in a configuration file. The script matches these patterns to:

1. The names of arguments in functions and methods and

2. The text of **return expressions**. Return expressions are the actual text of whatever follows the "return" keyword. The script removes all comments in return expressions and converts all strings to "str". This **preprocessing** greatly simplifies pattern matching.

As a first example, given the method:

    def foo(self, i, s):
        if i:
            return "abc" # a comment
        else:
            return s
        
and the patterns:

    i: int
    s: str
    
the script produces the stub:

    def foo(i: int, s: str) --&gt; str: ...

`make_stub_files` eliminates much of the drudgery of creating [python stub (.pyi) files](https://www.python.org/dev/peps/pep-0484/#stub-files) from python source files. Stub files can be used by people who use Python 2.x code bases.

</t>
<t tx="ekr.20160211110810.1">
### Command-line arguments

    usage: make_stub_files.py [options] file1, file2, ...

    make_stub_file: Create stub (.pyi) files from python files
    
    positional arguments:
      FILE                  input files
    
    optional arguments:
      -h, --help            show this help message and exit
      -c FILE, --config FILE
                            full path to configuration file
      -d DIR, --dir DIR     full path to the output directory
      -f, --force-pyx       force the parsing of .pyx files
      -o, --overwrite       overwrite existing stub (.pyi) files
      -s, --silent          run without messages
      --trace-matches       trace Pattern.matches
      --trace-patterns      trace pattern creation
      --trace-reduce        trace st.reduce_types
      --trace-visitors      trace visitor methods
      -u, --update          update stubs in existing stub file
      -v, --verbose         verbose output in .pyi file
      -w, --warn            warn about unannotated args

*Note*: glob.glob wildcards can be used in file1, file2, ...
</t>
<t tx="ekr.20160211110810.2">
### The configuration file

The --config command-line option specifies the full path to the optional configuration file. The configuration file uses the .ini format. It has several configuration sections, all optional.

</t>
<t tx="ekr.20160211110810.3">
### Why this script is important

The script eliminates most of the drudgery from creating stub files. The script produces syntactically and semantically correct stub files without any patterns at all. Patterns make it easy to make stubs more specific.

Once we create stub files, mypy will check them by doing real type inference. This will find errors both in the stub files and in the program under test. There is now an easy way to use mypy!

Stubs express design intentions and intuitions as well as types. Until now, there has been no practical way of expressing and *testing* these assumptions. Now there is.

Using mypy, we can be as specific as we like about types. We can simply annotate that d is a dict, or we can say that d is a dict whose keys are strings and whose values are executables with a union of possible signatures. Stubs are the easy way to play with type inference.

Finally, stubs can simplify the general type inference problem. Without type hints or annotations, the type of everything depends on the type of everything else. Stubs could allow robust, maybe even complete, type inference to be done locally. Stubs help mypy to work faster.
</t>
<t tx="ekr.20160211110811.1">
### Summary

The make-stub-files script does for type/design analysis what Leo's c2py command did for converting C sources to python. It eliminates much of the drudgery associated with creating stub files, leaving the programmer to make non-trivial inferences.

Stub files allow us to explore type checking using mypy as a guide and helper. Stub files are both a design document and an executable, checkable, type specification. Stub files allow those with a Python 2 code base to use mypy.

One could imagine a similar insert_annotations script that would inject function annotations into source files using stub files as data. The "reverse" script should be more straightforward than this script.

Edward K. Ream  
January 25 to February 15, 2016
Revised, August 5, 2021.
</t>
<t tx="ekr.20160211111807.1">
#### Patterns

The [Def Name Patterns] and [General Patterns] configuration sections
specify patterns. All patterns have the form:

    find-string: replacement-string
    
Colons are not allowed in the find-string. This is a limitation of .ini files.

There are three kinds of patterns: balanced, regex and plain.

**Balanced patterns** are patterns whose find string that:

A: contain either `(*)`, `[*]`, or `{*}` or

B: ends with `*`.

Unlike regular expressions, `(*)`, `[*]`, or `{*}` match only
balanced brackets. A trailing `*` matches the rest of the string.

Examples:

    str(*): str
    StubTraverser.do_*
    
Balanced patterns such as:

    [*]: List[*]

work as expected. The script replaces the `*` in replacement-strings with
whatever matched `*` in the find-string.

**Regex patterns** (regular expression patterns) are denoted by a
find-string that ends with `$`. The trailing `$` does not become part of
the find-string. For example:

    ab(.*)de$: de\1\1ab

A pattern is a **plain pattern** if it is neither a balanced nor a regex
pattern.

The script matches patterns to *all parts* of return expressions.

*Important*: The script applies patterns *separately* to each return
expression. Comments never appear in return expressions, and all strings in
return values appear as str. As a result, there is no context to worry
about context in which patterns are matched. Very short patterns suffice.

</t>
<t tx="ekr.20160211111823.1">
#### [Global]

This configuration section specifies the files list, prefix lines and
output directory. For example:

    [Global]

    files:
        # Files to be used *only* if no files are given on the command line.
        # glob.glob wildcards are supported.
        ~/leo-editor/leo/core/*.py
        
    output_directory:
        # The output directory to be used if no --dir option is given.
        ~/stubs
        
    prefix:
        # Lines to be inserted at the start of each stub file.
        from typing import TypeVar, Iterable, Tuple
        T = TypeVar('T', int, float, complex)
</t>
<t tx="ekr.20160211111839.1">
#### [Def Name Patterns]

The script matches the find-strings in this section against names of
functions and methods. For methods, the script matches find-strings against
names of the form:

    class_name.method_name

When a find-string matches, the replacement-string becomes the return type
in the stub, without any further pattern matching. That is, this section
*overrides* [General Patterns].

Example 1:

    [Def Name Patterns]
    myFunction: List[str]
    
Any function named myFunction returns List[str].

Example 2:

    [Def Name Patterns]
    MyClass.myMethod: str
    
The myMethod method of the MyClass class returns str.

Example 3:

    [Def Name Patterns]
    MyClass.do_*: str
    
All methods of the MyClass class whose names start with "do_" return str.
</t>
<t tx="ekr.20160211111901.1">
#### [General Patterns]

For each function or method, the script matches the patterns in this
section against **all parts** of all return expressions in each function or method.

The intent of the patterns in this section should be to **reduce** return
expressions to **known types**. A known type is a either a name of a type
class, such as int, str, long, etc. or a **type hint**, as per
[Pep 484](https://www.python.org/dev/peps/pep-0484/).

The script *always* produces a syntactically correct stub, even if the
patterns do not reduce the return expression to a known type. For unknown
types, the script does the following:

1. Uses Any as the type of the function or method.

2. Follows the stub with a list of comments giving all the return
   expressions in the function or method.
   
For example, suppose that the patterns are not sufficient to resolve the
return type of:

    def foo(a):
        if a:
            return a+frungify(a)
        else:
            return defrungify(a)
         
The script will create this stub:

    def foo(a) --&gt; Any: ...
        # return a+frungify(a)
        # return defrungify(a)
        
The comments preserve maximal information about return types, which should
help the user to supply a more specific return type. The user can do this
in two ways by altering the stub files by hand or by adding new patterns to
the config file.
</t>
<t tx="ekr.20160211113019.1">
### Quick Start

1. Put `make_stub_files.py` on your path.

2. Enter a directory containing .py files:

        cd myDirectory
    
3. Generate stubs for foo.py in foo.pyi:

        make_stub_files foo.py

4. Look at foo.pyi to see the generated stubs.

5. Regenerate foo.pyi with more verbose output:

        make_stub_files foo.py -o -v

   The -o (--overwrite) option allows the script to overwrite foo.pyi.  
   The -v (--verbose) options generates return comments for all stubs in foo.pyi.
   
6. Update foo.pyi:

        make_stub_files -o -u
        
   The -u (--update) options updates foo.pyi as follows:
   
   - adds stubs to foo.pyi for classes and defs that are new in foo.py.
   - deletes stubs in foo.pyi for classes and defs that no longer exist in foo.py.
   - leaves all other stubs in foo.pyi unchanged.
   
7. Specify a configuration file containing patterns:

        make_stub_files -c myConfigFile.cfg -o
</t>
<t tx="ekr.20160318141204.167"># UnaryOp(unaryop op, expr operand)

def do_UnaryOp(self, node: Node) -&gt; str:
    """StubFormatter.UnaryOp for unary +, -, ~ and 'not' operators."""
    op = self.op_name(node.op)
    if op.strip() == 'not':
        return 'bool'
    s = op + self.visit(node.operand)  # bug fix: 2021/08/07.
    s = self.match_all(node, s)
    self.trace_visitor(node, op, s)
    return s
</t>
<t tx="ekr.20160318141204.168">def do_Return(self, node: Node) -&gt; str:
    """
    StubFormatter ast.Return vsitor.
    Return only the return expression itself.
    """
    s = AstFormatter.do_Return(self, node)
    s = s.strip()
    assert s.startswith('return'), repr(s)
    return s[len('return'):].strip()
</t>
<t tx="ekr.20160318141204.18">def visit(self, node: Node) -&gt; str:
    """Return the formatted version of an Ast node, or list of Ast nodes."""
    tag = 'AstFormatter.visit'
    name = node.__class__.__name__
    ### g.trace(name) ###
    if isinstance(node, (list, tuple)):
        return ','.join([self.visit(z) for z in node])  # pragma: no cover (defensive)
    if node is None:
        return 'None'  # pragma: no cover
    method_name = 'do_' + node.__class__.__name__
    method = getattr(self, method_name, None)
    if method:
        s = method(node)
        assert isinstance(s, str), s.__class__.__name__
        return s
    # #13: *Never* ignore missing visitors!
    #      Insert an error comment directly into the output.
    message = f"\n#{tag}: no visitor: do_{name}\n"  # pragma: no cover (defensive)
    print(message, flush=True)  # pragma: no cover (defensive)
    return message  # pragma: no cover (defensive)
</t>
<t tx="ekr.20160318141204.191">def format_return_expressions(self,
    node: Node, name: str, raw_returns: List[Any], reduced_returns: List[Any]
) -&gt; str:
    """
    aList is a list of maximally reduced return expressions.
    For each expression e in Alist:
    - If e is a single known type, add e to the result.
    - Otherwise, add Any # e to the result.
    Return the properly indented result.
    """
    assert len(raw_returns) == len(reduced_returns)
    lws = '\n' + ' ' * 4
    n = len(raw_returns)
    known = all(is_known_type(e) for e in reduced_returns)
    empty = not any(isinstance(z, ast.FunctionDef) for z in node.body)
    tail = ': ...' if empty else ':'
    # pylint: disable=no-else-return
    if not known or self.verbose:
        # First, generate the return lines.
        aList = []
        for i in range(n):
            e, raw = reduced_returns[i], raw_returns[i]
            known2 = ' ' if is_known_type(e) else '?'
            aList.append('# %s %s: %s' % (' ', i, raw.rstrip()))
            aList.append('# %s %s: return %s' % (known2, i, e))
        results = ''.join([lws + self.indent(z) for z in aList])
        # Put the return lines in their proper places.
        if known:
            s = reduce_types(reduced_returns, name=name, trace=self.trace_reduce)
            return s + tail + results
        return 'Any' + tail + results
    s = reduce_types(reduced_returns, name=name, trace=self.trace_reduce)
    return s + tail
</t>
<t tx="ekr.20160318141204.20"># ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list)

def do_ClassDef(self, node: Node) -&gt; str:
    result = []
    name = node.name  # Only a plain string is valid.
    bases = [self.visit(z) for z in node.bases] if node.bases else []
    if getattr(node, 'decorator_list', None):
        for decorator in node.decorator_list:
            result.append(f"@{self.visit(decorator)}\n")  # Bug fix: 2021/08/06.
    if getattr(node, 'keywords', None):
        for keyword in node.keywords:
            bases.append('%s=%s' % (keyword.arg, self.visit(keyword.value)))
    # Fix issue #2: look ahead to see if there are any functions in this class.
    empty = not any(isinstance(z, ast.FunctionDef) for z in node.body)
    tail = ' ...' if empty else ''
    if bases:
        result.append(
            self.indent('class %s(%s):%s\n' % (name, ', '.join(bases), tail)))
    else:
        result.append(self.indent('class %s:%s\n' % (name, tail)))  # Fix #2
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)

</t>
<t tx="ekr.20160318141204.31"># arguments = (
#       arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,
#       expr* kw_defaults, arg? kwarg, expr* defaults
# )

def do_arguments(self, node: Node) -&gt; str:
    """Format the arguments node."""
    kind = self.kind(node)
    assert kind == 'arguments', kind
    args = [self.visit(z) for z in node.args]
    defaults = [self.visit(z) for z in node.defaults]
    # Assign default values to the last args.
    args2 = []
    # PEP 570: Position-only args.
    posonlyargs = getattr(node, 'posonlyargs', [])
    if posonlyargs:
        for z in posonlyargs:
            args2.append(self.visit(z))
        args2.append('/')
    # Regular args.
    n_plain = len(args) - len(defaults)
    for i in range(len(args)):
        if i &lt; n_plain:
            args2.append(args[i])
        else:
            args2.append('%s=%s' % (args[i], defaults[i - n_plain]))
    # PEP 3102: keyword-only args.
    if node.kwonlyargs:
        assert len(node.kwonlyargs) == len(node.kw_defaults)
        args2.append('*')
        for n, z in enumerate(node.kwonlyargs):
            if node.kw_defaults[n] is None:
                args2.append(self.visit(z))
            else:
                args2.append('%s=%s' % (self.visit(z), self.visit(node.kw_defaults[n])))
    # Add the vararg and kwarg expressions.
    vararg = getattr(node, 'vararg', None)
    if vararg:
        args2.append('*' + self.visit(vararg))
    kwarg = getattr(node, 'kwarg', None)
    if kwarg:
        args2.append('**' + self.visit(kwarg))
    return ', '.join(args2)
</t>
<t tx="ekr.20160318141204.35"># Call(expr func, expr* args, keyword* keywords)

def do_Call(self, node: Node) -&gt; str:
    func = self.visit(node.func)
    args = [self.visit(z) for z in node.args]
    for z in node.keywords:
        # Calls f.do_keyword.
        args.append(self.visit(z))
    return '%s(%s)' % (func, ', '.join(args))
</t>
<t tx="ekr.20160318141204.36"># keyword = (identifier arg, expr value)

def do_keyword(self, node: Node) -&gt; str:
    """Handle keyword *arg*, not a Python keyword!"""
    # node.arg is a string.
    value = self.visit(node.value)
    return '%s=%s' % (node.arg, value) if node.arg else '**%s' % value

</t>
<t tx="ekr.20160318141204.41">def do_Index(self, node):  # pragma: no cover (python 2)
    return self.visit(node.value)

</t>
<t tx="ekr.20160318141204.46">def do_Repr(self, node):  # pragma: no cover (Python 2.x only)
    return 'repr(%s)' % self.visit(node.value)

</t>
<t tx="ekr.20160318141204.5">def merge_types(a1, a2):
    '''
    a1 and a2 may be strings or lists.
    return a list containing both of them, flattened, without duplicates.
    '''
    # Only useful if visitors could return either lists or strings.
    assert a1 is not None
    assert a2 is not None
    r1 = a1 if isinstance(a1, (list, tuple)) else [a1]
    r2 = a2 if isinstance(a2, (list, tuple)) else [a2]
    return sorted(set(r1 + r2))

</t>
<t tx="ekr.20160318141204.59"># AnnAssign(expr target, expr annotation, expr? value, int simple)

def do_AnnAssign(self, node: Node) -&gt; str:
    return self.indent('%s: [%s] = %s\n' % (
        self.visit(node.target),
        self.visit(node.annotation),
        self.visit(node.value)))

def do_Assign(self, node: Node) -&gt; str:
    return self.indent('%s = %s\n' % (
        '='.join([self.visit(z) for z in node.targets]),
        self.visit(node.value)))
</t>
<t tx="ekr.20160318141204.65">def do_Exec(self, node):  # pragma: no cover (Python 2.x only)
    body = self.visit(node.body)
    args = []  # Globals before locals.
    if getattr(node, 'globals', None):
        args.append(self.visit(node.globals))
    if getattr(node, 'locals', None):
        args.append(self.visit(node.locals))
    if args:
        return self.indent('exec %s in %s\n' % (
            body, ','.join(args)))
    return self.indent('exec %s\n' % (body))

</t>
<t tx="ekr.20160318141204.74">def do_Print(self, node):  # pragma: no cover (Python 2.x only)
    vals = []
    for z in node.values:
        vals.append(self.visit(z))
    if getattr(node, 'dest', None):
        vals.append('dest=%s' % self.visit(node.dest))
    if getattr(node, 'nl', None):
        vals.append('nl=%s' % node.nl)
    return self.indent('print(%s)\n' % ','.join(vals))

</t>
<t tx="ekr.20160318141204.75">def do_Raise(self, node: Node) -&gt; str:
    args = []
    for attr in ('exc', 'cause'):
        if getattr(node, attr, None) is not None:
            args.append(self.visit(getattr(node, attr)))
    args_s = f" {', '.join(args)}" if args else ''
    return self.indent('raise%s\n' % args_s)


</t>
<t tx="ekr.20160318141204.80">def do_TryExcept(self, node):  # pragma: no cover (python 2)
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.handlers:
        for z in node.handlers:
            result.append(self.visit(z))
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)

</t>
<t tx="ekr.20160318141204.81">def do_TryFinally(self, node):  # pragma: no cover (python 2)
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append(self.indent('finally:\n'))
    for z in node.finalbody:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)

</t>
<t tx="ekr.20160318141204.83"># With(withitem* items, stmt* body)

def do_With(self, node: Node) -&gt; str:
    result = []
    result.append(self.indent('with '))
    vars_list = []
    if getattr(node, 'items', None):
        for item in node.items:
            result.append(self.visit(item.context_expr))
            result.append(' as ')
            if getattr(item, 'optional_vars', None):
                try:
                    for z in item.optional_vars: # pragma: no cover (expect TypeError)
                        vars_list.append(self.visit(z))
                except TypeError:
                    vars_list.append(self.visit(item.optional_vars))
                
    result.append(','.join(vars_list))
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160318141204.84">def do_Yield(self, node: Node) -&gt; str:
    # do_Expr has already indented this *expression*.
    if getattr(node, 'value', None):
        return 'yield %s' % self.visit(node.value)
    return 'yield'
</t>
<t tx="ekr.20160318141204.85"># YieldFrom(expr value)

def do_YieldFrom(self, node: Node) -&gt; str:
    # do_Expr has already indented this *expression*.
    return 'yield from %s' % self.visit(node.value)
</t>
<t tx="ekr.20160318141204.91"># Return generic markers to allow better pattern matches.

def do_Constant(self, node: Node) -&gt; str:
    return 'None' if node.value is None else node.value.__class__.__name__

def do_BoolOp(self, node: Node) -&gt; str:  # pragma: no cover (obsolete)
    return 'bool'

def do_Bytes(self, node: Node) -&gt; str:  # pragma: no cover (obsolete)
    return 'bytes'

def do_Name(self, node: Node) -&gt; str:  # pragma: no cover (obsolete)
    return 'bool' if node.id in ('True', 'False') else node.id

def do_Num(self, node: Node) -&gt; str:  # pragma: no cover (obsolete)
    return 'number'

def do_Str(self, node: Node) -&gt; str:  # pragma: no cover (obsolete)
    """This represents a string constant."""
    return 'str'
</t>
<t tx="ekr.20160330201030.1">Metadata-Version: 1.0
Name: make_stub_files
Version: 0.2
Summary: make stub files for mypy
Home-page: https://github.com/edreamleo/make-stub-files
Author: Edward K. Ream
Author-email: edreamleo@gmail.com
License: MIT
Description:
    usage: make_stub_files.py [options] file1, file2, ...
    
    Create stub (.pyi) files using patterns, not type inference.
    
    positional arguments:
      FILE                  input files
    
    optional arguments:
      -h, --help            show this help message and exit
      -c FILE, --config FILE
                            full path to configuration file
      -d DIR, --dir DIR     full path to the output directory
      -f, --force-pyx       force the parsing of .pyx files
      -o, --overwrite       overwrite existing stub (.pyi) files
      -s, --silent          run without messages
      --trace-matches       trace Pattern.matches
      --trace-patterns      trace pattern creation
      --trace-reduce        trace st.reduce_types
      --trace-visitors      trace visitor methods
      -u, --update          update stubs in existing stub file
      -v, --verbose         verbose output in .pyi file
      -w, --warn            warn about unannotated args

Download URL: https://github.com/edreamleo/make-stub-files
Keywords: mypy, type checking, stub, Python
Platform: Windows, Linux, MacOS
Categories:
    Development Status :: 4 - Beta
    License :: OSI Approved :: MIT License
    Operating System :: MacOS
    Operating System :: Microsoft :: Windows
    Operating System :: POSIX :: Linux
    Programming Language :: Python3
    Topic :: Software Development
</t>
<t tx="ekr.20180706073424.1"># pyflakes complains about the TestClass class.</t>
<t tx="ekr.20210804020706.1">g.cls()
command = r"python -m pytest --cov-report html --cov-report term-missing --cov make_stub_files make_stub_files.py"
g.execute_shell_commands(command, trace=False)
</t>
<t tx="ekr.20210804021331.1">g.cls()
"""Run make_stub_files with the given set of arguments."""
cfg = r'c:\users\Edward~1\make_stub_files.cfg'
msf = 'make_stub_files.py'
src = 'make_stub_files.py'
command = f"python {msf} -c {cfg} -o -v {src} -h"
g.execute_shell_commands(command, trace=False)</t>
<t tx="ekr.20210804060105.1">"""Run all unit tests"""
g.cls()
command = f"python -m unittest make_stub_files"
g.execute_shell_commands(command, trace=False)</t>
<t tx="ekr.20210804153200.1">"""Convert all following @test nodes."""
g.cls()

def body(p):
    def_s = f"def {headline(p)}(self):\n"
    lines = [' '*4 + z.rstrip()+'\n' for z in g.splitLines(p.b) if '@others' not in z]
    return def_s + ''.join(lines)

def headline(p):
    return p.h[1:].replace('-','_').replace(' ','_').replace('__', '_')

while p:
    if p.h.startswith('@test'):
        if 1:  # Change.
            print(p.h)
            p.b = body(p)  # body first, to use original headline.
            p.h = headline(p)
            p.setDirty()
        else:  # Report.
            h = headline(p)
            b = body(p)
            print(h.rstrip())
            print(b.rstrip())
            print('-'*40)
    p.moveToThreadNext()
c.redraw()
</t>
<t tx="ekr.20210804214511.1">def do_Constant(self, node: Node) -&gt; str:  # #13
    return repr(node.value)
</t>
<t tx="ekr.20210805053830.1">@language rest

https://github.com/edreamleo/make-stub-files/issues/18

Regex to add return annotations:

find: ^(def .*)(:\s*?)$
repl: \1 -&gt; XXX:

@language python
@nosearch
</t>
<t tx="ekr.20210805061637.1"></t>
<t tx="ekr.20210806162349.1"></t>
<t tx="ekr.20210807133351.1">g.cls()
# Run one test.
# test = '.TestMakeStubFiles.test_stub_formatter_class'
# test = '.TestMakeStubFiles.test_ast_arg_formatter_class'
# test = '.TestMakeStubFiles.test_st_format_returns'
# test = '.TestMakeStubFiles.test_rt_is_known_type'
# test = '.TestMakeStubFiles.test_pattern_class'
# test = '.TestMakeStubFiles.test_controller_class'
# test = '.TestMakeStubFiles.test_stub_formatter_class'
test = '.TestMakeStubFiles.test_stub_traverser_class'
command = f"python -m unittest make_stub_files{test}"
g.execute_shell_commands(command, trace=False)</t>
<t tx="ekr.20210807151105.1"></t>
<t tx="ekr.20210807213637.1"></t>
<t tx="ekr.20210809094659.1">"""
Use a separate file to launch make_stub_file.py to test the stubs in
make_stub_files.pyi.
"""
# This doesn't work: mypy complains that make_stub_file has not "main" member!
import os
import sys
# import make_stub_files
from make_stub_files import main
print('main', main)
if 0:
    fn = __file__
    directory = os.path.dirname(fn)
    print('directory', directory)
    for z in sys.path:
        print(z)
    if directory not in sys.path:
        sys.path.insert(0, directory)
        print('Add directory', directory)
sys.argv = ['python', 'make_stub_files.py']
# print(dir(make_stub_files))
main()
</t>
<t tx="ekr.20210809124558.1"># make_stub_files: Mon 09 Aug 2021 at 12:44:15
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20210809124613.1">from typing import Any, Dict, Optional, Sequence, Tuple, Union
Node = Any
</t>
<t tx="ekr.20210809124613.10">class AstFormatter:
    @others
</t>
<t tx="ekr.20210809124613.100">class LeoGlobals:
    @others
</t>
<t tx="ekr.20210809124613.101">def _callerName(self, n: int=1, files: bool=False) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.102">def caller(self, i: int=1) -&gt; Any: ...
    #   0: return self.callers(i+1).split(',')[0]
    # ? 0: return self.callers(int).split(str)[int]
</t>
<t tx="ekr.20210809124613.103">def callers(self, n: int=4, count: int=0, excludeCaller: bool=True, files: bool=False) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.104">def cls(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.105">def objToString(self, obj: Any, indent: str='', printCaller: bool=False, tag: str=None) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.106">def dictToString(self, d: Dict[Any, Any], indent: str='', tag: str=None) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.107">def listToString(self, obj: Any, indent: str='', tag: str=None) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.108">def tupleToString(self, obj: Any, indent: str='', tag: str=None) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.109">def pdb(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.11">def format(self, node: Node) -&gt; Any: ...
    #   0: return val
    # ? 0: return val
</t>
<t tx="ekr.20210809124613.110">def printObj(self, obj: Any, indent: str='', printCaller: bool=False, tag: str=None) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.111">def shortFileName(self, fileName: str, n: int=None) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.112">def splitLines(self, s: str) -&gt; Union[Any, List]: ...
</t>
<t tx="ekr.20210809124613.113">def trace(self, *args: Optional[List], **keys: Optional[List]) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.114">class Pattern:
    @others
</t>
<t tx="ekr.20210809124613.115">def __init__(self, find_s: str, repl_s: str='') -&gt; None: ...
</t>
<t tx="ekr.20210809124613.116">def __eq__(self, obj: Any) -&gt; bool: ...
</t>
<t tx="ekr.20210809124613.117">def __ne__(self, obj: Any) -&gt; bool: ...
</t>
<t tx="ekr.20210809124613.118">def __hash__(self) -&gt; int: ...
</t>
<t tx="ekr.20210809124613.119">def __repr__(self) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.12">def visit(self, node: Node) -&gt; Any: ...
    #   0: return ','.join(self.visit(z) for z in node)
    #   0: return str
    #   1: return 'None'
    #   1: return str
    #   2: return s
    #   2: return str
    #   3: return message
    # ? 3: return message
</t>
<t tx="ekr.20210809124613.120">def is_balanced(self) -&gt; bool: ...
</t>
<t tx="ekr.20210809124613.121">def is_regex(self) -&gt; Any: ...
    #   0: return self.find_s.endswith('$')
    # ? 0: return self.find_s.endswith(str)
</t>
<t tx="ekr.20210809124613.122">def all_matches(self, s: str) -&gt; List[Any]: ...
</t>
<t tx="ekr.20210809124613.123">def full_balanced_match(self, s: str, i: int) -&gt; Optional[int]: ...
</t>
<t tx="ekr.20210809124613.124">def match_balanced(self, delim: str, s: str, i: int) -&gt; int: ...
</t>
<t tx="ekr.20210809124613.125">def match(self, s: str, trace: bool=False) -&gt; Tuple[bool, str]: ...
</t>
<t tx="ekr.20210809124613.126">def match_entire_string(self, s: str) -&gt; Union[bool, bool(Union[Any, bool])]: ...
</t>
<t tx="ekr.20210809124613.127">def replace(self, m: Any, s: str) -&gt; Any: ...
    #   0: return self.replace_balanced(s, start, end)
    # ? 0: return self.replace_balanced(str, start, end)
    #   1: return self.replace_regex(m, s)
    # ? 1: return self.replace_regex(m, str)
</t>
<t tx="ekr.20210809124613.128">def replace_balanced(self, s1: str, start: int, end: int) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.129">def replace_regex(self, m: Any, s: str) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.13">def do_ClassDef(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.130">class ReduceTypes:
    @others
</t>
<t tx="ekr.20210809124613.131">def __init__(self, aList: List[str]=None, name: str=None, trace: bool=False) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.132">def is_known_type(self, s: str) -&gt; Union[Union[Any, bool], bool]: ...
</t>
<t tx="ekr.20210809124613.133">def reduce_collection(self, aList: List[str], kind: str) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.134">def reduce_numbers(self, aList: List[str]) -&gt; List[Any]: ...
</t>
<t tx="ekr.20210809124613.135">def reduce_types(self) -&gt; Any: ...
    #   0: return self.show('None')
    # ? 0: return self.show(str)
    #   1: return self.show(r[0])
    # ? 1: return self.show(str)
    #   2: return self.show('Union[%s]'%', '.join(sorted(r)))
    # ? 2: return self.show(str)
</t>
<t tx="ekr.20210809124613.136">def reduce_unknowns(self, aList: List[str]) -&gt; Any: ...
    #   0: return z if self.is_known_type(z) else 'Any'  for z in aList
    # ? 0: return Union[Any, str] for z in List[Any]
</t>
<t tx="ekr.20210809124613.137">def show(self, s: str, known: bool=True) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.138">def split_types(self, s: str) -&gt; List[Any]: ...
</t>
<t tx="ekr.20210809124613.139">class Stub:
    @others
</t>
<t tx="ekr.20210809124613.14">def do_FunctionDef(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.140">def __init__(self, kind: str, name: str, parent: 'Stub'=None, stack: List[str]=None) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.141">def __eq__(self, obj: Any) -&gt; bool: ...
</t>
<t tx="ekr.20210809124613.142">def __ne__(self, obj: Any) -&gt; bool: ...
</t>
<t tx="ekr.20210809124613.143">def __hash__(self) -&gt; int: ...
</t>
<t tx="ekr.20210809124613.144">def __repr__(self) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.145">def level(self) -&gt; int: ...
</t>
<t tx="ekr.20210809124613.146">def parents(self) -&gt; Any: ...
    #   0: return self.full_name.split('.')[:-1]
    # ? 0: return self.full_name.split(str)[:-int]
</t>
<t tx="ekr.20210809124613.147">class StubFormatter(AstFormatter):
    @others
</t>
<t tx="ekr.20210809124613.148">def __init__(self, controller: Controller, traverser: 'StubTraverser') -&gt; None: ...
</t>
<t tx="ekr.20210809124613.149">def match_all(self, node: Node, s: str, trace: bool=False) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.15">def do_Interactive(self, node: Node) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.150">def trace_visitor(self, node: Node, op: str, s: str) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.151">def do_Attribute(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.152">def do_Constant(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.153">def do_Bytes(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.154">def do_Num(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.155">def do_Str(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.156">def do_Dict(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.157">def do_List(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.158">def do_Name(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.159">def do_Tuple(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.16">def do_Module(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.160">def do_BinOp(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.161">def do_BoolOp(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.162">def do_Compare(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.163">def do_IfExp(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.164">def do_Subscript(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.165">def do_UnaryOp(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.166">def do_Call(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.167">def do_Return(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.168">class StubTraverser(ast.NodeVisitor):
    @others
</t>
<t tx="ekr.20210809124613.169">def __init__(self, controller: Controller) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.17">def do_Lambda(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.170">def add_stub(self, d: Dict[str, Stub], stub: Stub) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.171">def indent(self, s: str) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.172">def out(self, s: str) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.173">def run(self, node: Node) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.174">def output_stubs(self, stub: Stub) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.175">def output_time_stamp(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.176">def update(self, fn: str, new_root: Stub, contents: str=None, silent: bool=False) -&gt; Any: ...
    #   0: return new_root
    # ? 0: return new_root
    #   1: return new_root
    # ? 1: return new_root
    #   2: return new_root
    # ? 2: return new_root
    #   3: return old_root
    # ? 3: return old_root
</t>
<t tx="ekr.20210809124613.177">def get_stub_file(self, fn: str) -&gt; Any: ...
    #   0: return open(fn, 'r').read()
    # ? 0: return open(str, str).read()
    #   1: return None
    #   1: return None
    #   2: return None
    #   2: return None
</t>
<t tx="ekr.20210809124613.178">def parse_stub_file(self, s: str, root_name: str) -&gt; Tuple[Any, Any]: ...
</t>
<t tx="ekr.20210809124613.179">def merge_stubs(self, new_stubs: List[Stub], old_root: Stub, new_root: Stub, trace: bool=False) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.18">def do_Expr(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.180">def check_delete(self, new_stubs: List[Stub], old_root: Stub, new_root: Stub, trace: bool) -&gt; Any: ...
    #   0: return delete_list
    # ? 0: return delete_list
</t>
<t tx="ekr.20210809124613.181">def flatten_stubs(self, root: Stub) -&gt; List[Any]: ...
</t>
<t tx="ekr.20210809124613.182">def flatten_stubs_helper(self, root: Stub, aList: List[Stub]) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.183">def find_parent_stub(self, stub: Stub, root: Stub) -&gt; Optional[Any]: ...
</t>
<t tx="ekr.20210809124613.184">def find_stub(self, stub: Stub, root: Stub) -&gt; Any: ...
    #   0: return root
    # ? 0: return root
    #   1: return stub2
    # ? 1: return stub2
    #   2: return None
    #   2: return None
</t>
<t tx="ekr.20210809124613.185">def sort_stubs_by_hierarchy(self, stubs1: List[Stub]) -&gt; Any: ...
    #   0: return result
    # ? 0: return result
    #   1: return []
    #   1: return List
</t>
<t tx="ekr.20210809124613.186">def trace_stubs(self, stub: Stub, aList: List[str]=None, header: str=None, level: int=-1) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.187">def visit_ClassDef(self, node: Node) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.188">def visit_FunctionDef(self, node: Node) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.189">def format_arguments(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.19">def do_Expression(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.190">def munge_arg(self, s: str) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.191">def format_returns(self, node: Node) -&gt; Any: ...
    #   0: return 'None'+tail
    #   0: return str
    #   1: return s+': ...'
    #   1: return str
    #   2: return self.format_return_expressions(node, name, raw, r)
    # ? 2: return self.format_return_expressions(Node, str, raw, r)
</t>
<t tx="ekr.20210809124613.192">def format_return_expressions(self, node: Node, name: str, raw_returns: List[Any], reduced_returns: List[Any]) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.193">def get_def_name(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.194">def remove_recursive_calls(self, name: str, raw: List[str], reduced: List[str]) -&gt; Tuple[Any, Any]: ...
</t>
<t tx="ekr.20210809124613.195">def visit_Return(self, node: Node) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.196">class TestMakeStubFiles(unittest.TestCase):
    @others
</t>
<t tx="ekr.20210809124613.197">def test_rt_is_known_type(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.198">def test_rt_reduce_numbers(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.199">def test_rt_reduce_types(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.2">def dump(title: str, s: str=None) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.20">def do_GeneratorExp(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.200">def test_rt_split_types(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.201">def test_st_find(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.202">def test_st_flatten_stubs(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.203">def test_st_merge_stubs(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.204">def test_st_format_returns(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.205">def test_bug2_empty(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.206">def test_bug2_non_empty(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.207">def test_bug3(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.208">def test_finalize(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.209">def test_is_known_type(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.21">def do_AugLoad(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.210">def test_truncate(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.211">def test_ast_arg_formatter_class(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.212">def test_ast_formatter_class(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.213">def test_ast_formatter_class_on_file(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.214">def test_controller_class(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.215">def test_file_msb(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.216">def test_pattern_class(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.217">def test_stub_class(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.218">def test_stub_formatter_class(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.219">def test_stub_traverser_class(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.22">def do_Del(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.23">def do_Load(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.24">def do_Param(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.25">def do_Store(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.26">def do_arguments(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.27">def do_arg(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.28">def do_Attribute(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.29">def do_Bytes(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.3">def dump_dict(title: str, d: Dict[str, Any]) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.30">def do_Call(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.31">def do_keyword(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.32">def do_Constant(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.33">def do_comprehension(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.34">def do_Dict(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.35">def do_Ellipsis(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.36">def do_ExtSlice(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.37">def do_FormattedValue(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.38">def do_JoinedStr(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.39">def do_List(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.4">def dump_list(title: str, aList: List[Any]) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.40">def do_ListComp(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.41">def do_Name(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.42">def do_NameConstant(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.43">def do_Num(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.44">def do_Slice(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.45">def do_Str(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.46">def do_Subscript(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.47">def do_Tuple(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.48">def do_BinOp(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.49">def do_BoolOp(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.5">def finalize(fn: str) -&gt; Any: ...
    #   0: return os.path.normpath(os.path.abspath(os.path.expanduser(fn)))
    # ? 0: return os.path.normpath(os.path.abspath(os.path.expanduser(str)))
</t>
<t tx="ekr.20210809124613.50">def do_Compare(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.51">def do_UnaryOp(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.52">def do_IfExp(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.53">def do_Assert(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.54">def do_AnnAssign(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.55">def do_Assign(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.56">def do_AugAssign(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.57">def do_Break(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.58">def do_Continue(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.59">def do_Delete(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.6">def is_known_type(s: str) -&gt; Any: ...
    #   0: return ReduceTypes().is_known_type(s)
    # ? 0: return ReduceTypes().is_known_type(str)
</t>
<t tx="ekr.20210809124613.60">def do_ExceptHandler(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.61">def do_For(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.62">def do_Global(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.63">def do_If(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.64">def do_Import(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.65">def get_import_names(self, node: Node) -&gt; Any: ...
    #   0: return result
    # ? 0: return result
</t>
<t tx="ekr.20210809124613.66">def do_ImportFrom(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.67">def do_Nonlocal(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.68">def do_Pass(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.69">def do_Raise(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.7">def main() -&gt; None: ...
</t>
<t tx="ekr.20210809124613.70">def do_Return(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.71">def do_Starred(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.72">def do_Try(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.73">def do_While(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.74">def do_With(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.75">def do_Yield(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.76">def do_YieldFrom(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.77">def kind(self, node: Node) -&gt; Any: ...
    #   0: return node.__class__.__name__
    # ? 0: return Node.__class__.__name__
</t>
<t tx="ekr.20210809124613.78">def indent(self, s: str) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.79">def op_name(self, node: Node, strict: bool=True) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.8">def reduce_types(aList: List[str], name: str=None, trace: bool=False) -&gt; Any: ...
    #   0: return ReduceTypes(aList, name, trace).reduce_types()
    # ? 0: return ReduceTypes(List[Any], str, bool).reduce_types()
</t>
<t tx="ekr.20210809124613.80">class AstArgFormatter(AstFormatter):
    @others
</t>
<t tx="ekr.20210809124613.81">def do_Constant(self, node: Node) -&gt; Union[Any, str]: ...
</t>
<t tx="ekr.20210809124613.82">def do_BoolOp(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.83">def do_Bytes(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.84">def do_Name(self, node: Node) -&gt; Union[Any, str]: ...
</t>
<t tx="ekr.20210809124613.85">def do_Num(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.86">def do_Str(self, node: Node) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.87">class Controller:
    @others
</t>
<t tx="ekr.20210809124613.88">def __init__(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.89">def make_stub_file(self, fn: str) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.9">def truncate(s: str, n: int) -&gt; str: ...
</t>
<t tx="ekr.20210809124613.90">def scan_command_line(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.91">def scan_options(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.92">def make_op_name_dict(self) -&gt; Any: ...
    #   0: return d
    # ? 0: return d
</t>
<t tx="ekr.20210809124613.93">def create_parser(self) -&gt; Any: ...
    #   0: return parser
    # ? 0: return optparse.OptionParser
</t>
<t tx="ekr.20210809124613.94">def find_pattern_ops(self, pattern: 'Pattern') -&gt; Any: ...
    #   0: return []
    #   0: return List
    #   1: return ops
    # ? 1: return ops
</t>
<t tx="ekr.20210809124613.95">def get_config_string(self) -&gt; Any: ...
    #   0: return f.read()
    # ? 0: return f.read()
    #   1: return ''
    #   1: return str
</t>
<t tx="ekr.20210809124613.96">def init_parser(self, s: str) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.97">def is_section_name(self, s: str) -&gt; Any:
    #   0: return s.strip().lower().replace(' ', '')
    # ? 0: return str.strip().lower().replace(str, str)
    #   1: return True
    #   1: return bool
    #   2: return False
    #   2: return bool
    def munge(s: str) -&gt; Any: ...
        #   0: return s.strip().lower().replace(' ', '')
        # ? 0: return str.strip().lower().replace(str, str)
</t>
<t tx="ekr.20210809124613.98">def make_patterns_dict(self) -&gt; None: ...
</t>
<t tx="ekr.20210809124613.99">def scan_patterns(self, section_name: str) -&gt; List[Any]: ...
</t>
<t tx="ekr.20210810052454.1"></t>
<t tx="ekr.20210810052527.1"></t>
<t tx="ekr.20210810052805.1"></t>
<t tx="ekr.20210810053434.1">
### Release notes

Are you sure you want to use this program? For python 3 programs, including
mypy annotations directly in your sources is a better alternative. Leo's
new add-mypy-annotations command handles most of the tedious details of
inserting annotations.

Version 1.0: August 10, 2021.

- make_stub_files (msf) now requires Python 3.6 or above.
- Use traditional unit tests instead of Leo's deprecated @test nodes.
  These tests provide 100% coverage.
- Add several Leo buttons.
  - Use the coverage and unittest buttons to run tests.
  - Use the msf button to run make_stub_files.py on itself.
- Fix all known bugs.
- A new unit test that ensures that all required ast visitors exist.
- Add scripts/wax_off.py.
</t>
<t tx="ekr.20210810115607.1"></t>
</tnodes>
</leo_file>
